---
const name = "ahmetdem";
---

<section>
  <p id="username">{name}@<span id="browser-info"></span> |</p>
  <input id="terminal-input" type="text" />
</section>

<style>
  section {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    gap: 20px;
    padding: 5px;
    border-radius: var(--border-radius);
    background-color: white;
    border: 1px solid black; /* Add this to visualize each section */
  }

  p {
    font-family: var(--monospace-font-family);
    font-size: 20px;
  }

  #username {
    color: rgb(0, 0, 0); /* Change this to any color you want */
  }

  #browser-info {
    font-size: 20px;
    font-weight: 500;
  }

  #terminal-input {
    background: none;
    border: none;
    font-family: var(--monospace-font-family);
    font-size: 20px;
    color: var(--text-color);
    width: 750px;
  }

  #terminal-input:focus {
    border: none;
    outline: none;
  }

  @media only screen and (max-width: 1200px) {
    section {
      flex-direction: column;
      align-items: flex-start;
    }
    #terminal-input {
      width: 300px;
    }
  }
</style>

<p id="browser-info"></p>

<script>
  const p = document.getElementById("browser-info");
  const userAgent = navigator.userAgent;
  let browser = "unknown";

  if (userAgent.indexOf("Chrome") !== -1) {
    browser = "chrome";
  } else if (userAgent.indexOf("Firefox") !== -1) {
    browser = "zen";
  }

  p.textContent = "ahmetdem";

  const input = document.getElementById("terminal-input");
  const examples = [
    "how to tie a tie?",
    "today's weather",
    "search on reddit with r:query",
    "search stackoverflow with s:query",
    "make the terminal great again",
    "hey sexy! wanna kill all humans?",
    "press ctrl+c to clear",
    "Bunu okuyan gaydÄ±r.",
  ];

  let exampleIndex = 0;
  let charIndex = 0;
  let typingSpeed = 50; // Speed of typing effect

  function typePlaceholder() {
    if (charIndex < examples[exampleIndex].length) {
      input.placeholder += examples[exampleIndex].charAt(charIndex);
      charIndex++;
      setTimeout(typePlaceholder, typingSpeed);
    } else {
      setTimeout(() => {
        input.placeholder = "";
        charIndex = 0;
        exampleIndex = (exampleIndex + 1) % examples.length;
        typePlaceholder();
      }, 2000);
    }
  }

  typePlaceholder();

  // Automatically focus the input when the page loads
  input.focus();

  // Focus the input when any key is pressed
  document.addEventListener("keydown", function () {
    input.focus();
  });

  input.addEventListener("keydown", function (event) {
    let value = input.value.toLowerCase();
    let elements = document.querySelectorAll("a");

    let matchFound = false;
    if (event.ctrlKey && event.key === "c") {
      input.value = "";
      for (let i = 0; i < elements.length; i++) {
        let element = elements[i];
        element.style.mixBlendMode = "";
      }
    }
    for (let i = 0; i < elements.length; i++) {
      let element = elements[i];
      if (value === "" || event.keyCode !== 13) {
        continue;
      }
      if (
        element.textContent
          .toLowerCase()
          .indexOf(value.replace(/^r:|^s:/, "")) !== -1
      ) {
        window.location.href = element.href;
        matchFound = true;
        break;
      }
    }
    if (!matchFound && event.keyCode === 13) {
      if (value === "help") {
        document.getElementById("help").style.display = "block";
        document.getElementById("overlay").classList.add("active");
      } else if (value.startsWith("r:")) {
        window.location.href =
          "https://google.com/search?q=site:reddit.com " +
          value.replace("r:", "");
      } else if (value.startsWith("s:")) {
        window.location.href =
          "https://google.com/search?q=site:stackoverflow.com " +
          value.replace("s:", "");
      } else if (value.startsWith("m:")) {
        window.location.href =
          "https://google.com/search?q=site:myanimelist.net " +
          value.replace("m:", "");
      } else if (value.startsWith("gay hakan")) {
        window.location.href = "https://myanimelist.net/profile/Asteria";
      } else {
        let words = value.split(".");
        if (words.length >= 2) {
          window.location.href = "http://" + value;
        } else {
          window.location.href = "https://google.com/search?q=" + value;
        }
      }
    }
  });

  input.addEventListener("input", function () {
    let value = input.value.toLowerCase();
    let elements = document.querySelectorAll("a");
    for (let i = 0; i < elements.length; i++) {
      let element = elements[i];
      if (value === "") {
        element.style.mixBlendMode = "";
      } else if (
        element.textContent
          .toLowerCase()
          .indexOf(value.replace(/^r:|^s:/, "")) !== -1
      ) {
        element.style.mixBlendMode = "";
      } else {
        element.style.mixBlendMode = "color-burn";
      }
    }
  });

  let commandHistory = [];
  let historyIndex = -1;

  input.addEventListener("keydown", function (event) {
    if (event.key === "ArrowUp") {
      if (historyIndex > 0) {
        historyIndex--;
        input.value = commandHistory[historyIndex];
      }
      event.preventDefault();
    } else if (event.key === "ArrowDown") {
      if (historyIndex < commandHistory.length - 1) {
        historyIndex++;
        input.value = commandHistory[historyIndex];
      } else {
        input.value = "";
        historyIndex = commandHistory.length;
      }
      event.preventDefault();
    } else if (event.key === "Enter") {
      let command = input.value.trim();
      if (command !== "") {
        commandHistory.push(command);
        historyIndex = commandHistory.length;
      }
    }
  });

  function startSnakeGame() {
    // Create the game container
    const gameContainer = document.createElement("div");
    gameContainer.style.position = "fixed";
    gameContainer.style.top = "50%";
    gameContainer.style.left = "50%";
    gameContainer.style.transform = "translate(-50%, -50%)";
    gameContainer.style.border = "2px solid white";
    gameContainer.style.backgroundColor = "black";
    gameContainer.style.zIndex = "1000";
    document.body.appendChild(gameContainer);

    // Create the canvas
    const canvas = document.createElement("canvas");
    canvas.width = 300;
    canvas.height = 300;
    gameContainer.appendChild(canvas);
    const ctx = canvas.getContext("2d");

    // Close button
    const closeButton = document.createElement("button");
    closeButton.textContent = "Exit Game";
    closeButton.style.position = "absolute";
    closeButton.style.top = "10px";
    closeButton.style.left = "50%";
    closeButton.style.transform = "translateX(-50%)";
    closeButton.style.backgroundColor = "red";
    closeButton.style.color = "white";
    closeButton.style.border = "none";
    closeButton.style.padding = "5px 10px";
    closeButton.style.cursor = "pointer";
    closeButton.addEventListener("click", () => {
      document.body.removeChild(gameContainer);
    });
    gameContainer.appendChild(closeButton);

    // Snake Game Variables
    const gridSize = 20;
    let snake = [{ x: 5, y: 5 }];
    let food = { x: 10, y: 10 };
    let dx = 1;
    let dy = 0;
    let gameInterval;

    function draw() {
      // Clear the canvas
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw the food
      ctx.fillStyle = "red";
      ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize, gridSize);

      // Draw the snake
      ctx.fillStyle = "lime";
      snake.forEach((segment) => {
        ctx.fillRect(
          segment.x * gridSize,
          segment.y * gridSize,
          gridSize,
          gridSize,
        );
      });
    }

    function update() {
      const head = { x: snake[0].x + dx, y: snake[0].y + dy };

      // Check for collision (wall or itself)
      if (
        head.x < 0 ||
        head.y < 0 ||
        head.x >= canvas.width / gridSize ||
        head.y >= canvas.height / gridSize ||
        snake.some((segment) => segment.x === head.x && segment.y === head.y)
      ) {
        alert("Game Over! Try Again.");
        clearInterval(gameInterval);
        document.body.removeChild(gameContainer);
        return;
      }

      // Check if food is eaten
      if (head.x === food.x && head.y === food.y) {
        food = {
          x: Math.floor(Math.random() * (canvas.width / gridSize)),
          y: Math.floor(Math.random() * (canvas.height / gridSize)),
        };
      } else {
        snake.pop();
      }

      snake.unshift(head);
    }

    function handleKeyPress(event) {
      if (event.key === "ArrowUp" && dy === 0) {
        dx = 0;
        dy = -1;
      } else if (event.key === "ArrowDown" && dy === 0) {
        dx = 0;
        dy = 1;
      } else if (event.key === "ArrowLeft" && dx === 0) {
        dx = -1;
        dy = 0;
      } else if (event.key === "ArrowRight" && dx === 0) {
        dx = 1;
        dy = 0;
      }
    }

    document.addEventListener("keydown", handleKeyPress);

    // Start the game loop
    gameInterval = setInterval(() => {
      update();
      draw();
    }, 150);
  }

  // Modify the input event listener to launch the game
  input.addEventListener("keydown", function (event) {
    if (event.key === "Enter") {
      let value = input.value.toLowerCase();
      if (value === "game") {
        startSnakeGame();
        input.value = "";
      }
    }
  });

  const table = document.getElementById("help");

  function exitTable() {
    table.style.display = "none";
    document.getElementById("overlay").classList.remove("active");
    const input = document.getElementById("terminal-input");
    input.value = "";
    input.focus(); // Re-focus the input after closing the help table

    const elements = document.querySelectorAll("a");
    for (let i = 0; i < elements.length; i++) {
      let element = elements[i];
      element.style.mixBlendMode = "";
    }
  }

  document.addEventListener("keydown", function (event) {
    if (event.keyCode === 27) {
      exitTable();
    }
  });

  const closeTableButton = document.getElementById("closeTable");

  closeTableButton.onclick = function () {
    exitTable();
  };
</script>
